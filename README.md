## Welcome To My Developer Diary
Hello, my name is Svante Drakenberg. I've created this repository to serve as the home for all the different projects I'm planning to work on. Its purpose it to demonstrate my capabilities as a software developer in a convenient and easily understood way. 
## What is the purpose of this repository?
As of writing this (23/08/2024), I am about a year away from taking my bachelor's degree in Computer Science. When exploring different jobs and careers I've been faced with the same question from many different recruiters, "do you have a GitHub I could look at?". This obviously isn't an unexpected question to get, but it made me realize the awkward situation I was in.

My approach towards getting a career in software development has always been simple. I've never been picky, so I always imagined getting a job to be relatively easy. As long as I got my degree, everything else would naturally fall into place. This might still be the case since I haven't actually gotten my degree yet, but I've started reconsidering how I want to approach software development outside of my education.

Put simply, I want some way aside from my academic degree to show what I'm capable of. Ideally this would be something I'd already be doing, but I've previously felt limited in my ability to start personal projects. To be honest, this can partially be attributed to poor planning on my part, but issues with personal health has been the main deterrent towards committing myself to projects outside of school. I don't have any of these problems today, so starting a long-term project is something I'm both excited and motivated to do.

To close of this section I just want to make clear, that I have in fact, written code. I would estimate that around 40% of my time at KTH have been related to software development in some way. I might be able to share some amount of this code but this isn't something I'll be doing. The main reason for this is that several courses at KTH seem to have the same assignments each time they are taught. I'm fairly certain that I would be breaking some sort of rules by sharing my solutions to these assignments. Even if that wasn't the case, I wouldn't feel comfortable potentially aiding others in cheating.

Even though I'm not sharing any of my code written at KTH, I might still talk about a particular solution if I thought it was interesting for one reason of another. As an example, as a part of a course about programming paradigms we were suppose to write a compiler for a simple, made up language. Implementing lexical tokenization (converting the raw text into tokens) was recommended to do with the `java.util.regex` package, but how does that work exactly? In truth most implementations of regular expressions simply translate a string specifying valid patterns, into a corresponding DFA (Deterministic finite automaton). Instead of relying on the abstractions given to us by the package, why can't we just determine the DFA for the lexical tokenization ourselves? I implemented my regular expression as an array, representing the state transition table of the underlying DFA. Everything worked as expected and it was a fun way to demystify regular expressions. Most of my solutions that I find interesting usually involve looking at an implementation at a lower level of abstraction. Abstraction is really useful in a lot of practical situations, but relying too much on abstraction can limits ones understanding of what the code is actually doing. 

## My capabilities
What capabilities do I have that I want to demonstrate?
- Software development
	- Algorithms and data structures
	- Distributed version control
		- Git, GitHub
	- Databases
	- Working with different programming paradigms
		- imperative programming: procedural and object-oriented
			- C, C++ and Java
		- Declarative: Functional and logical
			- Haskell and prolog
		- Dynamically typed
			- Python, MATLAB
	- Working with or close to operating systems
- Mathematics
	- Multivariable and vector calculus
	- Algebra and geometry
	- Discrete mathematics
	- Numerical methods
	- Probability and statistics